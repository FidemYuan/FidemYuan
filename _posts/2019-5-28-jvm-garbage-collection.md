---
layout: post
title: jvm内存划分与垃圾回收机制
categories: JavaSE
tags: jvm
author: fidemyuan
---

## jvm规范中的内存划分

1.程序计数器（寄存器）<br>

线程私有的，可以看作是当前线程所执行字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>

这时唯一一个没有规定任何 OOM 异常的区域。

2.虚拟机栈<br>

虚拟机栈也是线程私有的，生命周期与线程相同。栈里面存储的是方法的局部变量、对象的引用等等。<br>

在这片区域中，规定了两种异常情况，当线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常。当虚拟机栈动态扩展无法申请到足够的内存时会抛出 OOM 异常。<br>

3.本地方法栈<br>

和虚拟机栈的作用相同，只不过它是为 Native 方法服务。HotSpot 虚拟机直接将虚拟机栈和本地方法栈合二为一了。<br>

4.堆

堆是 Java 虚拟机所管理内存中最大的一块。是所有线程共享的一块内存区域，在虚拟机启动时创建。这个区域唯一的作用就是存放对象实例，也就是 NEW 出来的对象。这个区域也是 Java 垃圾收集器的主要作用区域。<br>

当堆的大小再也无法扩展时，将会抛出 OOM 异常。<br>

5.方法区

方法区也是线程共享的内存区域，用于存储已经被虚拟机加载的类信息、常量、静态变量等等。当方法区无法满足内存分配需求时，会抛出 OOM 异常。这个区域也被称为永久代。<br>

###三种虚拟机

1.sun公司的HotSpot<br>
2.BEA公司的Jrockit<br>
前两个公司被Oracle收购合并.....合成新的jvm JDK1.8中<br>
3.IBM的J9VM<br>

### JDK1.8中JVM

把方法区改为了元空间

对于方法区，它是线程共享的，主要用于存储类的信息，常量池，方法数据，方法代码等。我们称这个区域为永久代。

### 一些常见问题

 、String a = new String("xyz");、

问：这段代码创建了几个对象，都存在 JVM 中的哪个位置？<br>

答：答案是两个对象，第一个是通过 NEW 关键字创建出来的 a 对象，它的存储位置当然是在堆中。第二个是 xyz 这个对象，它存在常量池中（String 在 Java 中被定义为不可变的对象，类的定义和方法都是 final 的，所以会被当作常量看待）。<br>

问：a 对象的引用存在哪里？<br>

答：对象的引用全部存在栈中。<br>

问：Java 中各个对象、变量、类的存储位置？<br>

答：NEW 出来的对象存储在堆中，局部变量和方法的引用存在栈中，类的相关信息、常量和静态变量存在方法区中，1.8以后使用元空间存储类相关信息。<br>

问：Java 中会有内存溢出问题吗？发生在哪些情况下？<br>

答：JVM 的堆、栈、方法区、本地方法栈、直接内存都会发生内存溢出问题。典型的堆溢出的例子：集合持有大量对象并且长期不释放。典型的栈溢出例子：无法快速收敛的递归。典型的方法区溢出例子：加载了大量的类或者 JSP 的程序。<br>


## 垃圾回收

###  如何判断对象已死

1.引用计数器（会产生问题）<br>

每当有一个地方引用它时，计数器值就加一，引用失效时，计数器值减一。简单高效，但是没办法解决循环引用的问题。<br>

2.可达性分析算法<br>

这个算法的基本思路就是通过一系列名为 GC ROOTS 的对象作为起始点，从这些节点开始向下搜索。当一个对象到 GC ROOTS 没有任何引用链接时，则证明此对象时不可用的。<br>

可以作为 GC ROOTS 的对象包括下面几种：<br>

方法里引用的对象。<br>
方法区中的类静态属性引用的对象。<br>
方法区中的常量引用的对象。<br>
本地方法中引用的对象。<br>

HotSpot 虚拟机采用的是可达性分析算法。<br>

### finalize对象的自我拯救

对象有三种状态：<br>

1.可达：
2.可恢复状态:
3.不可达:

当一个对象被创建出来是可达状态，该对象会先变为可恢复状态，在这个状态下，如果满足：<br>
1.finalize方法重写<br>
2.finalize方法 有且只能执行一次<br>
那么就会执行finalize方法，进行对象的自我抢救，对象可能就会从可恢复状态再到可达状态。<br>

### Java中final、finally、finalize的区别与用法

final：java中的关键字，修饰符。<br>
A).如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。<br>
B).如果将变量或者方法声明为final，可以保证它们在使用中不被改变.<br>
　　1)被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。<br> 
　　2)被声明final的方法只能使用，不能重载。<br> '

finally：java的一种异常处理机制。<br> 
　　finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。<br> 

finalize：Java中的一个方法名。<br> 
Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。（答上面叙述的）<br>

### 垃圾回收策略

在知道了如何判断对象是否是垃圾以后，垃圾回收机制其实是根据分代的策略对对象进行处理<br>

**一、堆内存中的划分**：<br>
在堆内存中分为年轻代和年老代，年轻代：年老代为1:2<br>

在年轻代中分为Eden:to suvior(s0):from suvior(s1)为8:1:1<br>
注：Eden伊甸园区，to suvior幸存者区0区，from suvior幸存者1区。<br>

**二、垃圾回收算法**<br>

1.标记清除算法<br>

算法分为标记和清除两个阶段，首先要标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。<br>

缺点：1.效率问题，标记和清除过程的效率都不高<br>

     2.会有不连续的内存碎片。<br>

2.复制清除算法，比如将存活的对象复制到另一个空间中，再将一开始的空间所有的对象都清除。<br>
 
   分配担保原则：销毁垃圾的速度跟不上产生垃圾的速度时，就处罚分配担保原则，将对象直接放置到年老代中。<br>

   优点：<br>
	1.速度块<br>
	2.没有内存碎片<br>
  缺点：<br>
	
  复制算法在对象存活率较高时就要执行较多的复制操作，效率会变的很低,而且需要占用更多的空间。而且如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对对象 100% 存活的极端情况，所以老年代一般不选复制算法，而选择标记-清除或者标记-整理算法。<br>


3.标记整理算法/标记压缩算法<br>

和标记-清除算法的标记过程一样，但后序有一个对内存进行整理的动作。比较适合要清除对象不多的情况。比如年老代，清除的对象不多，用标记镇里算法正好。用复制清除算法反而慢。<br>

优点：内存连续<br>
缺点：速度慢<br>

Minor GC：新生代 GC，指的是发生在新生代的垃圾回收动作，因为 Java 对象大多都具有朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。用的是复制清除算法<br>

Full GC：老年代 GC，出现了 Full GC，一般也会伴随至少一次的 Minor GC（非绝对的）用的是标记整理算法。<br>

**三、垃圾回收过程**<br>

一个对象创建出来是在Eden区，当 Eden 没有足够的空间进行分配时，虚拟机将发起一次 Minor GC。用可达性算法判断出垃圾以后，把不是垃圾的对象复制到s0区，在s0区满了会惊醒Minor GC，幸存的对象进入s1区，S1区满了会进行Minor GC幸存对象再进入S0区。开始循环，当达到15次以后（这个阈值可以设置一般是15次），对象就会进入年老区。<br>

当年老代的对象满了就会进行Full GC算法，如果执行Full GC算法以后仍然没有无法进行对象的保存，就会产生OOM异常（OutOfMemeryError）。<br>

## JVM的内存大小

默认是一个区间：默认初始值是计算机内存的1/64。根据需求的时候会瞬间扩容到计算机内存的1/4。<br>

但是再实际开发过程中为了避免不必要的浪费会将jvm的大小一般会固定。大小根据公司的实际开发确定，可能为内存的3/4。<br>










