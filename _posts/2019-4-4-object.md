---
layout: post
title:  "对象"
categories: Java
tags: java 
author: fidemyuan
---
## 用引用操纵对象

在java中一切都可以看做对象，在java程序中我们操纵的实际上是对象的引用。比如：

` String  str ="hello world !"`

这里的str就是一个引用了，写代码的时候我们都是通过操作str这个引用来操作"hello world!"字符串代码这个对象。因为str跟"hello world!"建立了连接。有点类似于遥控器跟电视机的关系，str相当于"hello world!"这个电视机的遥控器，通过“str”就可以操纵电视了。


## 基本类型的对象


byte: 8位 最大存储数据量是255，存放的数据范围是-128~127之间，初始值为：0。

short:16位最大数据存储量是65536，数据范围是-32768~32767之间，初始值为：0。

int:  32位最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1，初始值为：0。

long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1，初始值为：0。

float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F，初始值为：0.0f。

double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加，初始值为：0.0d。

boolean：只有true和false两个取值，初始值为：false。

char：16位，存储Unicode码，用单引号赋值，初始值为：0。


注意：除了上面这些特殊的基本类型，其他都是引用类型。数组、String类型都是引用类型。引用类型的初始值为null。

##  java中对象的存储位置

**1.寄存器**

最快的存储区，位于处理器内部，但是数量极其有限。所以寄存器根据需求进行自动分配，无法直接人为控制。

**2.栈内存**

位于RAM当中，通过堆栈指针可以从处理器获得直接支持。堆栈指针向下移动，则分配新的内存；向上移动，则释放那些内存。这种存储方式速度仅次于寄存器。

（常用于存放对象引用和基本数据类型，而不用于存储对象）

**3.堆内存**

一种通用的内存池，也位于RAM当中。其中存放的数据由JVM自动进行管理。

堆相对于栈的好处来说：编译器不需要知道存储的数据在堆里存活多长。当需要一个对象时，使用new写一行代码，当执行这行代码时，会自动在堆里进行存储分配。同时，因为以上原因，用堆进行数据的存储分配和清理，需要花费更多的时间。

**4.常量存储**

常量(字符串常量和基本类型常量)通常直接存储在程序代码内部（常量池）。这样做是安全的，因为它们的值在初始化时就已经被确定，并不会被改变。常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s = "java"这种申明方式

**5.非RAM存储区**

如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是：流对象和持久化对象。、

## 作用域

作用域表示所定义的变量名的可见性和生命周期，一般由`{ }`的位置来决定

### 变量的作用域
    `{
    int x = 12;
      /* only x available */
     {
          int q = 96;
          /* both x & q available */
      }
      /* only x available */
      /* q “out of scope” */
     }`

比如上面的x的作用域就是整个最外面的`{ }`的位置，q的作用域是里面`{ }`定义的位置。

注意在java中如下的定义是不允许的：

    `{
     int x = 12;
       {
         int x = 96; /* illegal */
       }
    }`

### 对象的作用域

在java中创造出来的对象域不同于基本类型，对象可以存活于作用域之外。比如：

     `{
          String s = new String("a string");
       
      } /* 作用域的终点 */`

引用s在作用域终点处就消失了。**可引用s指向的String类型的对象其实并没有消失**，java的设计者让这个对象仍继续在内存中占据空间，解决c++中遇到的编程问题。**java中有“垃圾回收器”的机制**，用来监视用new创建的所有对象，辨认并释放不会再被引用的对象的内存。所以java中永远不需要销毁对象。