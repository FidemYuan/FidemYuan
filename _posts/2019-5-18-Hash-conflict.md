---
layout: post
title: HashMap冲突算法
categories: JavaSE
tags: 集合
author: fidemyuan
---

## 一些基本概念

把任意长度的输入（输入叫做预映射，知道就行），通过一种函数（hashCode() 方法），变换成固定长度的输出，该输出就是**哈希值**（hashCode），这种函数就叫做**哈希函数**，而计算哈希值的过程就叫做**哈希**。哈希的主要应用是哈希表和分布式缓存。<br>

在将键值对存入数组之前，**将key通过哈希算法计算出哈希值，把哈希值作为数组下标**，把该下标对应的位置作为键值对的存储位置，通过该方法建立的数组就叫做**哈希表**，而这个存储位置就叫做桶（bucket）

## 什么叫哈希冲突

哈希表选用哈希函数计算哈希值时，可能不同的 key 会得到相同的哈希值，这就是哈希冲突（碰撞）。在HashMap中就会把相同哈希值（即数组的下标）相同的值组成一个单链表。 

## 解决哈希冲突

哈希冲突在数组上加了单链表，单链表的查询速度比较慢，因此要尽量避免哈希冲突不用遍历某个位置上的链表，查询效率就会提高。

**hash冲突算法**

部分代码：

key.hashCode()会得到一个32位的二级制数字，但是一般HashMap的数组长度的二级制位数是小于32的。如果直接用此HashCode进行计算重复的可能性会比较大，综合考虑是让这个哈希值的高16位与低16位进行异或运算生成新的16位的HashCode，位数不大也唯一。即(h=key.hashCode()^(h>>>16);高16位与上低16位。之所以要采取异或运算呢，是因为异或运算可以让出现0，1平均的可能性最高。新生成的HashCode相同的可能性就降低<br>

hash(key):

	`static final int hash(Object Key){
		int h;
		return (key == null )? 0:(h=key.hashCode())^(h>>>16);
		}`

......
<br>

为了让hashCode值转化为小于hashMap数组长度一个值，所以要用数组长度&上这个新的HashCode值。&运算是同一得一，不同得0。<br>

但是长度可能是奇数可能是偶数，偶数的二级制是X0000的形式与hashCode值做&运算的时候会改变对应HashCode的位数。由于HashCode的值是唯一的，改变了就可能产生相同的索引。而奇数的二级制形式：X1111的形式跟HashCode做&运算的时候可以尽可能的保留HashCode的对应位数，更能保证唯一性。所以java中固定HashMap的数组长度n必须是偶数。（n-1）就是奇数，跟新的HashCode相&可以尽可能的还原HashCode的值，避免哈希冲突。<br>


然后与（n-1）得到数组下标

    `(n-1) & hash`

