---
layout: post
title:  "赋值操作符"
categories: Java
tags: java 
author: fidemyuan
---

##  什么叫操作符

操作符，操作数据的符号，作用于操作数。在底层，在java中的数据都是通过操作符来操作的。操作符接受一个或多个参数，并生成新值，参数的形式不同于方法中的参数，比如a++。

##  赋值操作符

赋值的操作符：`=`，是将=右边的值复制给左边。右边可以是变量、常数、表达式，只要是一个值就行，左边不能是常量。

注意：赋值要区分基本类型跟对象引用的赋值两者是有区别的，如下：

###  对基本类型的赋值

基本类型的赋值是直接将一个值赋值到了另一个地方。比如：
	
 	`int a=3;
     int b=4;
	 a=b;//将b中存储的值赋值到a中存储
			`
这个时候b的值就赋值给了a这个时候a，b是独立的，之后b中的值改变了也不影响a。

### 对象之间的赋值

之前分享过，在java中操作对象是，是操作的对象的引用。那么c=d,是讲对象的"引用"d赋值给了另一个对象的“引用”c，而不是将实际对象中的值赋值了过去。所以此时c、d都指向了d原来指向的那个对象。换句话说，c、d作为对象的引用存储的是对象的地址值，赋值的时候是讲d的地址值赋值给了c。比如下面代码运行的结果：

`
	class Tank {
  		int level;
	  }

	public class test{
	public static void main(String[] args){
	Tank  t1 =new Tank();
	Tank  t2 =new Tank();
    t1.level= 9;
	t2.lecel=47;
	
	System.out.println("t1.level:"+t1.level+"t2.level:"+t2.level);

      t1=t2;
	System.out.println("t1.level:"+t1.level+"t2.level:"+t2.level);

    t1.level=27;

	System.out.println("t1.level:"+t1.level+"t2.level:"+t2.level)
      }
    
     }

    /*结果就是：
        9   47
        47  47
        27   27*/  
					`
## 算术运算符

+	加法 - 相加运算符两侧的值	
-	减法 - 左操作数减去右操作数	
*	乘法 - 相乘操作符两侧的值	
/	除法 - 左操作数除以右操作数
％	取余 - 左操作数除以右操作数的余数
	
++	自增: 操作数的值增加1	B++ 或 ++B 等于 21
--	自减: 操作数的值减少1	B-- 或 --B 等于 19


**注意：**

   前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算。

   后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算 


## 关系型运算符

关系型运算符是比较操作符两边的操作数的关系的，**会返回一个boolean值的类型。**

1. ==	检查如果两个操作数的值是否相等，如果相等则条件为真返回true,否则返回false。	
 !=	检查如果两个操作数的值是否相等，如果值不相等则条件为真返回true,否则返回false。	
1. > 	检查左操作数的值是否大于右操作数的值，如果是那么条件为真返回true,否则返回false。	
1. < 	检查左操作数的值是否小于右操作数的值，如果是那么条件为真返回true,否则返回false。	
1. >=	检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真返回true,否则返回false。	
1. <=	检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真返回true,否则返回false。


注意：对象的引用也可以用来做比较，用上面**关系型运算符比较的实际是对象的应用，引用里面放的是对象的实际地址，而不是对象里面的值。**比如下面代码的结果：

    `pulic  class Equivalence{
	 public  static  void main(String[]  args){
		Integer  n1 = new Integer(47);
        Integer  n2 = new Integer(47);
		System.out.println(n1==n2);//false
		System.out.println(n1 !=n2); //true

        }


    }`

 
   上面的两个对象中存储的值虽然一样，但关系运算符比较的是对象的引用n1、n2，这两个引用里面存储的地址是不一样的，所以结果是ture、false。

   如果要比较对象中存储的值就要用到所有对象都有的特殊方法：equals(),这个方法不适用于基本类型，基本类型使用“==”或“！=”即可。需要注意的是euqals()方法默认还是比较的是对象的引用，**一般的类都对equals()方法进行了重写，但是如果是自己创建的类，如果没有对equals()方法进行重写，还是不能直接比较对象中的值。**


## 逻辑操作符

&&	称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。	（A && B）为假。

| |	称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。	（A | | B）为真。

！	称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。	！（A && B）为真。

注意：短路，一旦编译器能够确定整个表达式的值，余下的部分就不会计算了。

比如`test(0) && test(2) && test(3)` 如果test(0)为true,test(1)为false,结果一定就是true,test(3)就不再执行。


## 位运算符

Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。

位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下：

A = 0011 1100
B = 0000 1101
-----------------
A&b = 0000 1100
A | B = 0011 1101
A ^ B = 0011 0001
~A= 1100 0011

下表列出了位运算符的基本运算,假设整数变量A的值为60和变量B的值为13：


 <table>
        <tr>
            <th>操作符</th>
            <th>描述</th>
            <th>例子</th>
     
        </tr>
        <tr>
            <th>&</th>
            <th>如果相对应位都是1，则结果为1，否则为0</th>
            <th>（A＆B），得到12，即0000 1100</th>
        </tr>
        <tr>
            <th>^</th>
            <th>如果相对应位值相同，则结果为0，否则为1</th>
            <th>（A ^ B）得到49，即 0011 0001</th>

        </tr>
        <tr>
            <th>〜</th>
            <th>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</th>
            <th>〜A）得到-61，即1100 0011</th>

        </tr>
        <tr>
            <th><<</th>
            <th>按位左移运算符。左操作数按位左移右操作数指定的位数。</th>
            <th>A << 2得到240，即 1111 0000</th>

        </tr>
        <tr>
            <th>>> </th>
            <th>	按位右移运算符。左操作数按位右移右操作数指定的位数。</th>
            <th>A >> 2得到15即 1111</th>

        </tr>
        <tr>
            <th>>>> </th>
            <th>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</th>
            <th>A>>>2得到15即0000 1111</th>

        </tr>
    </table>
## 三元操作符

三元运算符也被称为条件运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

### 形式

    `boolean-exp ? value0 : value1`

如果boolean-exp为ture,则计算value0；如果boolean-exp为false，则计算value1。计算的结果就是整个表达式最终的结果。

用法很多：
   return i<10 ? i*100: i*100;

或者：

    `public class Test {
       public static void main(String[] args){
         int a , b;
         a = 10;
         // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
         b = (a == 1) ? 20 : 30;
         System.out.println( "Value of b is : " +  b );//结果为30；
 
        // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
         b = (a == 10) ? 20 : 30;
         System.out.println( "Value of b is : " + b );//结果为：20；
        }
     }`

## instanceof 运算符

### 功能
该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。

### 格式
( Object reference variable ) instanceof  (class/interface type)
如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。

	`String name = "James";

	boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真`

## 字符串操作符

用来连接不同的字符串

### “+”

将操作符“+”左右两边的操作数连接起来。String类型比较特殊，如果表达式的一开始是String类型则后续的操作数都会变成字符串并连接，比如：
    `int x =0;
	 int y =1;
	 String s="x,y,z";
	 print(s+x+y+z);//结果是xyz012
`

###  "+="

将操作符右边的操作数连接到左边的操作数末尾
        `int x =0;
		 int y =1;
	 	String s="x,y,z";
		 s +="(summed)"//结果是xyz(summed)

注意：编译器会把用""符号内的字符序列自动转化为字符串。

## 类型转换操作符

类型转换操作符对数据进行类型转换，把一种数据类型转化为另一种数据类型。

如下图是基本类型所表示的数值范围图：

![](https://github.com/fidemyuan/fidemyuan.github.io/blob/master/img-folder/basic%20data%20type.jpg)

下图是基本数据类型之间的转化关系
![](https://github.com/fidemyuan/fidemyuan.github.io/blob/master/img-folder/type%20conversion.png)

实线指向表示可以直接自动转化，数据精度不会损失，虚线表示数据精度有可能会会有损失。

### 自动类型转化

当把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，系统将可以进行自动类型转换。数据不会有精度损失。只要该常量值不超过该类型的表示范围都能自动转换。


### 强制类型转化
把一种数据类型转化为另一种数据类型，不能自动转化的就需要强制转化，可能会有精度损失。
比如float跟double类型的数据转化为int类型的时候，会进行截尾。29.6赋值给int类型变量时，会为：29。
#### 类型转化操作符用法
将希望得到的数据类型置于圆括号内，放在要进行类型转化的数值左边



注意：自动转换也要小心数据溢出问题，看下面的例子。

	`int count = 100000000;
	int price = 1999;
	long totalPrice = count * price;`
编译没任何问题，但结果却输出的是负数，这是因为两个 int 相乘得到的结果是 int, **相乘的结果超出了 int 的代表范围**。这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。

	`int count = 100000000;
	int price = 1999;
	long totalPrice = (long) count * price;`

  把任何基本类型的值和字符串值进行连接运算时，基本类型的值将自动转换为字符串类型，即使字符串类型不再是基本类型，而是引用类型。因此，**如果希望把基本类型的值转换为对应的字符串，可以把基本类型的值和一个空字符串进行连接。**